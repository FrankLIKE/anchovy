/*
Copyright (c) 2013 Andrey Penechko

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license the "Software" to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module anchovy.gui.widget;

import std.traits;

import anchovy.gui.all;

public import anchovy.gui.interfaces.iwidget;

enum defaultAnchor = Sides.LEFT | Sides.TOP;

///
abstract class Widget : IWidget
{
public:

	this()
	{
		//_rect = initRect;
		//_prefferedSize = uvec2(_rect.width, _rect.height);
		//styleName = initStyleName;
		//skin = initSkin;
		//_textLine = new TextLine("", null);
		//init();
		addEventHandler(&handleDraw);
		addEventHandler(&handleUpdatePosition);
	}

	/// Called by a constructor.
	/// You can do custom init here.
	/*protected void init()
	{
	}*/

	/*override void calcStaticRect(Rect parentStaticRect) @safe
	{
		_staticRect = _rect.relativeToParent(parentStaticRect);
	}*/

//+-------------------------------------------------------------------------------+
//|                                   Drawing                                     |
//+-------------------------------------------------------------------------------+

	bool handleDraw(DrawEvent event)
	in
	{
		assert(event.guiRenderer !is null);
	}
	body
	{
		//writeln("handleDraw");
		if (_isBackgroundVisible && event.sinking)
			doDraw(event.guiRenderer);

		//if (_isContentVisible)
		//	drawContent(event.guiRenderer);
		return true;
	}

	void doDraw(IGuiRenderer renderer) 
	{
		//writeln("drawBackground");
		renderer.drawControlBack(this, staticRect);
	}

//+-------------------------------------------------------------------------------+
//|                                Event handling                                 |
//+-------------------------------------------------------------------------------+

	/*protected void applySizeConstraints()
	{
		_rect.clampSize(_minSize, _maxSize);
	}*/
	
	void updateStaticPosition()
	{
		if (_parent is null) return;
		_staticPosition = _position + _parent.staticPosition;
	}

	void handleResize() @trusted
	{
		//applySizeConstraints();
	}
	
	bool handleUpdatePosition(UpdatePositionEvent event)
	{
		if (event.sinking)
		{
			updateStaticPosition();
			return false;
		}
		return true;
	}
	
	void addEventHandler(T)(T handler)
	{
		static assert(isDelegate!T, "handler must be a delegate, not " ~ T.stringof);
		alias ParameterTypeTuple!T[0] eventType;
		static assert(!is(eventType == Event), "handler's parameter must not be Event class but inherited one");
		static assert(is(eventType : Event), "handler's parameter must be inherited from Event class");
		static assert(ParameterTypeTuple!T.length == 1, "handler must have only one parameter, Event's descendant");
		_eventHandlers[typeid(eventType)] ~= cast(bool delegate(Event))handler;
	}

	/// Returns true if event was handled
	/// This handler will be called by Gui class twice, before and after visiting its children.
	/// In first case sinking flag will be true;
	override bool handleEvent(Event e)
	{
		bool result = false;
		if (auto handlers = typeid(e) in _eventHandlers)
		{
			foreach(h; *handlers)
				result |= h(e);
		}
		return result;
	}

	override bool recursiveHandleEvent(Event e)
	{
		e.sinking = true;
		if (!handleEvent(e))
		{
			return false;
		}

		bool handled = false;
		foreach (widget; children) {
			e.sinking = true;
			handled |= widget.recursiveHandleEvent(e);
		}
		
		e.sinking = false;
		return handleEvent(e) || handled;
	}
	
//+-------------------------------------------------------------------------------+
//|                                  Properties                                   |
//+-------------------------------------------------------------------------------+

	override void addChild(IWidget child)
	{
		assert(false);
	}

	@property
	{
		/** 
		* Anchored sides of the widget.
		* Can be constructed by ORing Anchor values.
		* Examples:
		* ---
		* widget.anchor = Anchor.LEFT | Anchor.RIGHT;
		*  ---
		* See_Also:
		* 	_anchor
		*/
		override uint anchor()
		{
			return _anchor;
		}

		/// ditto
		override void anchor(uint newAnchor)
		{
			_anchor = newAnchor;
		}

		// Used internally by gui renderer.
		override ref TexRectArray[string] geometry()
		{
			return _geometry;
		}

		ivec2 minSize()
		{
			return _minSize;
		}
		
		override IWidget[] children()
		{
			return null;
		}

		override void parent(IWidget newParent)
		{
			if (newParent is null) return;
			_parent = newParent;
			updateStaticPosition();
			
			if (_skin is null && _isInheritsSkin)
			{
				skin = _parent.skin;
			}
		}

		override IWidget parent()
		{
			return _parent;
		}

		override void position(ivec2 newPosition)
		{
			_position = newPosition;
			updateStaticPosition();
		}

		override ivec2 position()
		{
			return _position;
		}
		
		override ivec2 staticPosition()
		{
			return _staticPosition;
		}
		
		override void userSize(ivec2 newSize)
		{
			_userSize = newSize;

			discardGeometry();//TODO: add check if size is the same
			handleResize();
		}

		override ivec2 userSize()
		{
			return _userSize;
		}
		
		override ivec2 prefferedSize()
		{
			return max(_userSize, _minSize);
		}

		override void skin(GuiSkin newSkin)
		{
			if (newSkin is null || newSkin == _skin) return;
			_skin = newSkin;
			writeln("skin changed");
			if (auto style = _skin[_style])
			{
				_minSize = style["normal"].minSize;
			}
			discardGeometry(); //TODO: add check if size is the same
			skinChanged();
		}

		override GuiSkin skin()
		{
			return _skin;
		}
		
		bool isInheritsSkin()
		{
			return _isInheritsSkin;
		}

		void isInheritsSkin(bool inherits)
		{
			if (_isInheritsSkin == inherits) return;

			_isInheritsSkin = inherits;

			if (_isInheritsSkin && parent !is null)
			{
				GuiSkin parentSkin = parent.skin;

				if (_skin != parentSkin)
					skin = parentSkin;
			}
		}

		override string state()
		{
			return _state;
		}

		override void state(string newState)
		{
			_state = newState;
			if (_skin is null || _skin[_style] is null) return;
			_minSize = _skin[_style][_state].minSize;
		}

		override string style()
		{
			return _style;
		}

		override void style(string newStyle)
		{
			_style = newStyle;
		}
	}

	protected Font getStyleFont(GuiSkin skin, in string styleName)
	{
		writeln("skin: ", skin);
		writeln("styleName: ", styleName);
		writeln("skin[styleName]: ", skin[styleName]);
		if (skin[styleName] is null) return null;
		string font = _skin[_style].fontName;
		writeln("fontName: ", font);
		Font* fontPtr = font in _skin.fonts;
		writeln("fontPtr: ", fontPtr);
		if (fontPtr is null) return null;
		writeln("font found");
		return *fontPtr;
	}

	void handleParentSkinChange()
	{
		if (_isInheritsSkin)
		{
			skin = parent.skin;
		}
	}

	protected void skinChanged()
	{
	}

protected:

	void discardGeometry() @safe
	{
		_geometry = null;
	}

	/** Stores sides to which this widget is anchored.
	See_Also:
	 	anchor
	*/
	uint _anchor = defaultAnchor;

	/// GuiRenderer can save here widgets geometry.
	/// This geometry can be shared between few widgets.
	TexRectArray[string] _geometry;

	/// Widget name. Mainly used when assembling anchovy.gui.
	string _name;

	/// Parent of this widget. Can be null if have no parent.
	IWidget	_parent;

	/// Position is relative to parent's position.
	ivec2 _position;

	/// Position is relative to window origin.
	/// Calculated in calculateStaticRect
	ivec2 _staticPosition;

	/// Widget size specified when creating widget.
	/// Used by layout manager to decide widgets preffered size. 
	/// Currrently used as minimal size for frame.
	ivec2 _userSize;

	/// Minimal size of the widget, specified by skin;
	ivec2 _minSize;

	/// 
	bool _isEnabled = true;

	/// True if widget inherits skin of parent.
	bool _isInheritsSkin = true;

	/// if true 
	bool _isContentVisible = true;

	/// 
	bool _isBackgroundVisible = true;

	/// Individual skin of the widget. Must be initialized as null if inherited from parent.
	GuiSkin		_skin;

	/// Current style state.
	string		_state = "normal";

	/// Style name in current skin.
	string		_style;

	/// Event handlers.
	bool delegate(Event)[][TypeInfo] _eventHandlers;
}